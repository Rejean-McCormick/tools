{
  "format": "wiki_dump_json",
  "format_version": 1,
  "generated_at": "2025-12-17T14:44",
  "title": "FOLDER: 02-structural-and-decoupling",
  "root_dir": "C:\\MyCode\\Tools\\The-Senior-Architect_s-Codex\\senior-architecture-patterns",
  "stats": {
    "file_count": 6,
    "total_size_bytes": 29830,
    "total_size_mb": 0.0284
  },
  "nav": {
    "home_file": "NoteBookIndex.json",
    "prev_file": "senior-architecture-patterns_20251217_1444_02_03-data-management-consistency.json",
    "next_file": "senior-architecture-patterns_20251217_1444_04_08-emerging-and-specialized.json",
    "prev_title": "03-data-management-consistency",
    "next_title": "08-emerging-and-specialized"
  },
  "files": [
    {
      "rel_path": "02-structural-and-decoupling/07-strangler-fig.md",
      "ext": ".md",
      "size_bytes": 4900,
      "kind": "markdown",
      "content": "# 07\\. Strangler Fig Pattern\n\n## 1\\. The Concept\n\nThe Strangler Fig Pattern involves incrementally migrating a legacy system by gradually replacing specific pieces of functionality with new applications and services. As features are migrated, the new system grows around the old one (like a Strangler Fig tree around a host tree), eventually intercepting all calls until the legacy system is strangled (decommissioned).\n\n## 2\\. The Problem\n\n  * **Scenario:** You have a massive 10-year-old Monolith (\"The Legacy App\") that is hard to maintain, full of bugs, and written in an outdated language. Business leadership wants to modernize it.\n  * **The Risk (The Big Bang Rewrite):**\n      * **The Freeze:** You stop adding features to the old app to focus on the rewrite. Business halts for 18 months.\n      * **The Moving Target:** By the time the rewrite is \"done\" 2 years later, the business requirements have changed, and the new app is already obsolete.\n      * **The Failure:** Most Big Bang rewrites are abandoned before they ever reach production.\n\n## 3\\. The Solution\n\nInstead of rewriting everything at once, you place a **Facade** (API Gateway, Load Balancer, or Proxy) in front of the legacy system.\n\n1.  Initially, the Facade routes 100% of traffic to the Legacy App.\n2.  You build **one** new microservice (e.g., \"User Profile\").\n3.  You update the Facade to route `/users` traffic to the new service, while everything else (`/orders`, `/products`) still goes to the Legacy App.\n4.  Repeat this process until the Legacy App has zero traffic.\n5.  Turn off the Legacy App.\n\n### Junior vs. Senior View\n\n| Perspective | Approach | Outcome |\n| :--- | :--- | :--- |\n| **Junior** | \"This old code is trash. Let's delete it all and start a fresh repository. We can probably rewrite it in 3 months.\" | **Catastrophe.** The rewrite takes 12 months. The team discovers hidden business logic in the old code that they missed. The project is cancelled. |\n| **Senior** | \"Don't touch the old code. Put a proxy in front of it. We will migrate the 'Search' module to a new service next sprint. If it works, we keep going. If it fails, we switch the route back instantly.\" | **Safety & Value.** Value is delivered continuously (weeks, not years). If the new architecture is bad, we find out early. The business never stops running. |\n\n## 4\\. Visual Diagram\n\n## 5\\. When to Use It (and When NOT to)\n\n  * ‚úÖ **Use when:**\n      * Migrating a Monolith to Microservices.\n      * Moving from On-Premise to Cloud.\n      * The legacy system is too large to rewrite in a single release cycle.\n      * You need to deliver new features *while* refactoring.\n  * ‚ùå **Avoid when:**\n      * **Small Systems:** If the app is small (e.g., \\< 20k lines of code), just rewrite it. The overhead of the Strangler pattern isn't worth it.\n      * **Tightly Coupled Database:** If the legacy code relies on massive 50-table SQL joins, you can't easily peel off one service without breaking the data layer. (See *Anti-Corruption Layer*).\n\n## 6\\. Implementation Strategy (The Routing Logic)\n\nThe magic happens in the **Routing Layer** (e.g., Nginx, AWS ALB, or a code-level Interceptor).\n\n### Step 1: The Setup (100% Legacy)\n\n```nginx\n# Nginx Configuration\nupstream legacy_backend {\n    server 10.0.0.1:8080;\n}\n\nserver {\n    listen 80;\n    \n    # Catch-all: Send everything to Legacy\n    location / {\n        proxy_pass http://legacy_backend;\n    }\n}\n```\n\n### Step 2: The Strangle (90% Legacy, 10% New)\n\nWe identified that `/api/v1/search` is the first candidate for migration. We build the `New Search Service`.\n\n```nginx\nupstream legacy_backend {\n    server 10.0.0.1:8080;\n}\n\nupstream new_search_service {\n    server 10.0.0.5:5000;\n}\n\nserver {\n    listen 80;\n\n    # 1. Intercept Search traffic\n    location /api/v1/search {\n        proxy_pass http://new_search_service;\n    }\n\n    # 2. Everything else still goes to Legacy\n    location / {\n        proxy_pass http://legacy_backend;\n    }\n}\n```\n\n### Step 3: Handling Data Synchronization\n\nThe hardest part is data. If the New Service needs data that the Legacy App writes, or vice versa, you often need a temporary sync mechanism.\n\n  * **Double Write:** The application writes to *both* the old DB and the new DB.\n  * **Change Data Capture (CDC):** A tool (like Debezium) watches the Legacy DB logs and syncs changes to the New DB in near real-time.\n\n## 7\\. Operational Notes\n\n  * **The \"Zombie\" Risk:** Sometimes the Strangler process stops halfway (e.g., 50% migrated). You are left with two systems to maintain (the worst of both worlds). You must commit to finishing the job.\n  * **Url Mapping:** You might need to maintain the old URL structure (`/old-app/user.php?id=1`) even in the new system to avoid breaking clients, or use the proxy to rewrite paths (`/users/1`)."
    },
    {
      "rel_path": "02-structural-and-decoupling/08-anti-corruption-layer.md",
      "ext": ".md",
      "size_bytes": 5047,
      "kind": "markdown",
      "content": "# 08\\. Anti-Corruption Layer (ACL)\n\n## 1\\. The Concept\n\nThe Anti-Corruption Layer (ACL) is a design pattern used to create a boundary between two subsystems that have different data models or semantics. It acts as a translator, ensuring that the \"messy\" or incompatible design of an external (or legacy) system does not leak into (\"corrupt\") the clean design of your modern application.\n\n## 2\\. The Problem\n\n  * **Scenario:** You are building a new, modern E-commerce system with a clean domain model (e.g., `Customer`, `Order`, `Product`). However, you must fetch customer data from a 20-year-old mainframe Legacy ERP.\n  * **The Legacy Reality:** The ERP uses cryptic column names like `CUST_ID_99`, `KUNNR`, `X_FLAG_2`, and stores dates as strings like `\"2023.12.31\"`.\n  * **The Risk:**\n      * **Pollution:** If you use the ERP's variable names and structures directly in your new code, your new business logic becomes tightly coupled to the old system's quirks.\n      * **Vendor Lock-in:** If you switch ERPs later, you have to rewrite your entire business logic because it is littered with `KUNNR` references.\n\n## 3\\. The Solution\n\nBuild a dedicated layer (class, module, or service) that sits between the two systems.\n\n1.  **Incoming:** It retrieves the ugly data from the Legacy System and **translates** it into your clean Domain Objects.\n2.  **Outgoing:** It takes your clean Domain Objects and **translates** them back into the ugly format required by the Legacy System.\n\nYour core business logic *never* sees the Legacy model. It only sees clean objects.\n\n### Junior vs. Senior View\n\n| Perspective | Approach | Outcome |\n| :--- | :--- | :--- |\n| **Junior** | \"The API returns a field called `xml_blob_v2`. I'll just pass that string around to the frontend and parse it where we need it.\" | **Infection.** The entire codebase becomes dependent on the specific XML format. If the external API changes, the whole app breaks. |\n| **Senior** | \"Create an ACL Service. Parse `xml_blob_v2` immediately at the edge. Convert it to a strongly-typed `Invoice` object. The rest of the app should not know XML exists.\" | **Isolation.** The core logic remains pure. If the external API changes to JSON, we only update the ACL. The business logic is untouched. |\n\n## 4\\. Visual Diagram\n\n## 5\\. When to Use It (and When NOT to)\n\n  * ‚úÖ **Use when:**\n      * **Legacy Migration:** Integrating a new microservice with a monolith.\n      * **Third-Party APIs:** Integrating with vendors (Salesforce, SAP, Stripe) whose data models don't match yours.\n      * **Mergers & Acquisitions:** Connecting two different systems from different companies.\n  * ‚ùå **Avoid when:**\n      * **Simple CRUD:** If your app is just a UI viewer for the external system, translating the data is unnecessary overhead.\n      * **Internal Communication:** If both services share the same \"Bounded Context\" and language, an ACL is overkill.\n\n## 6\\. Implementation Example (Pseudo-code)\n\n**Scenario:** We need to get a user's address.\n\n  * **Legacy System:** Returns a pipe-separated string: `\"123 Main St|New York|NY|10001\"`\n  * **Our System:** Expects a structured `Address` object.\n\n### The Wrong Way (Pollution)\n\n```python\n# Business Logic\ndef print_label(user_id):\n    # BAD: Leaking the external format into the core logic\n    raw_data = legacy_api.get_user(user_id) # Returns \"123 Main St|New York|NY|10001\"\n    parts = raw_data.split(\"|\") \n    print(f\"Ship to: {parts[1]}\") # If order of parts changes, this breaks.\n```\n\n### The Right Way (ACL)\n\n```python\n# 1. The Domain Model (Clean)\nclass Address:\n    def __init__(self, street, city, state, zip_code):\n        self.street = street\n        self.city = city\n        self.state = state\n        self.zip_code = zip_code\n\n# 2. The Anti-Corruption Layer (The Translator)\nclass LegacyUserACL:\n    def get_user_address(self, user_id) -> Address:\n        # Call the ugly external system\n        raw_response = legacy_api.get_user(user_id) \n        \n        # Translate / Adapt\n        try:\n            parts = raw_response.split(\"|\")\n            return Address(\n                street=parts[0],\n                city=parts[1],\n                state=parts[2],\n                zip_code=parts[3]\n            )\n        except IndexError:\n            raise DataCorruptionException(\"Legacy data format changed\")\n\n# 3. The Business Logic (Pure)\ndef print_label(user_id):\n    # The logic doesn't know about pipes or strings. It just knows 'Address'.\n    acl = LegacyUserACL()\n    address = acl.get_user_address(user_id)\n    print(f\"Ship to: {address.city}\") \n```\n\n## 7\\. Strategic Value\n\nThe ACL is not just code; it is a **Negotiation Boundary**.\n\n  * By implementing an ACL, you are explicitly deciding: *\"We will not let the technical debt of System A become the technical debt of System B.\"*\n  * It makes testing easier. You can mock the ACL interface and test your business logic without ever spinning up the heavy legacy system."
    },
    {
      "rel_path": "02-structural-and-decoupling/09-sidecar-pattern.md",
      "ext": ".md",
      "size_bytes": 5704,
      "kind": "markdown",
      "content": "# 09\\. Sidecar Pattern\n\n## 1\\. The Concept\n\nThe Sidecar pattern involves deploying components of an application into a separate process or container to provide isolation and encapsulation. Much like a motorcycle sidecar is attached to a motorcycle, a sidecar service is attached to a parent application and shares the same lifecycle (it starts and stops with the parent).\n\nIn modern Cloud-Native environments (like Kubernetes), this usually means running two containers inside the same **Pod**. They share the same network namespace (localhost), disk volumes, and memory resources, but run as distinct processes.\n\n## 2\\. The Problem\n\n  * **Scenario:** You have a microservices architecture with 50 services written in different languages (Node.js, Go, Python, Java).\n  * **The Requirement:** Every service needs to:\n    1.  Reload configuration dynamically when it changes.\n    2.  Establish Mutual TLS (mTLS) for secure communication.\n    3.  Ship logs to a central Splunk/ELK stack.\n    4.  Collect Prometheus metrics.\n  * **The Developer Nightmare:**\n      * You have to write libraries for Logging, Metrics, and SSL in **four different languages**.\n      * When the security team updates the SSL protocol, you have to redeploy 50 services.\n      * The \"Business Logic\" is cluttered with infrastructure code.\n\n## 3\\. The Solution\n\nOffload the \"Cross-Cutting Concerns\" (infrastructure tasks) to a **Sidecar Container**.\n\n1.  **The Application Container:** Only contains business logic. It speaks plain HTTP to `localhost`. It writes logs to `stdout`.\n2.  **The Sidecar Container:**\n      * **Proxy (Envoy/Nginx):** Intercepts traffic, handles mTLS decryption, and forwards plain HTTP to the App.\n      * **Log Shipper (Fluentd):** Reads the App's `stdout`, formats it, and sends it to Splunk.\n\n### Junior vs. Senior View\n\n| Perspective | Approach | Outcome |\n| :--- | :--- | :--- |\n| **Junior** | \"I'll install the `npm install splunk-logger` package in the Node app and `pip install splunk-lib` in the Python app.\" | **Maintenance Hell.** Every time the logging endpoint changes, you have to update code in 5 languages and redeploy every single service. |\n| **Senior** | \"The application should not know Splunk exists. It just prints to the console. A Fluentd sidecar picks up the logs and handles the shipping.\" | **Decoupling.** The app is pure logic. You can swap the logging vendor from Splunk to Datadog by just changing the sidecar configuration, without touching the app code. |\n\n## 4\\. Visual Diagram\n\n## 5\\. When to Use It (and When NOT to)\n\n  * ‚úÖ **Use when:**\n      * **Polyglot Environments:** You have services in multiple languages and want consistent behavior (logging, security) across all of them.\n      * **Service Mesh:** Systems like **Istio** or **Linkerd** rely entirely on sidecars (Envoy proxies) to manage traffic.\n      * **Legacy Apps:** Adding HTTPS/SSL to an old application that doesn't support it natively. Put an Nginx sidecar in front of it to handle SSL termination.\n  * ‚ùå **Avoid when:**\n      * **Small Scale:** If you have one monolith running on a VPS, running a sidecar adds complexity for no reason.\n      * **Inter-Process Latency:** While `localhost` is fast, adding a proxy sidecar does add a tiny bit of latency (sub-millisecond). In High-Frequency Trading, this might matter.\n\n## 6\\. Implementation Example (Kubernetes YAML)\n\nThe most common implementation is a Kubernetes Pod with multiple containers.\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app-pod\nspec:\n  containers:\n    # 1. The Main Application (The Motorcycle)\n    - name: my-business-app\n      image: my-company/billing-service:v1\n      ports:\n        - containerPort: 8080\n      # The app writes logs to /var/log/app.log\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log\n\n    # 2. The Sidecar (The Sidecar)\n    - name: log-shipper-sidecar\n      image: busybox\n      # Reads the shared log file and ships it (simulated here with tail)\n      command: [\"/bin/sh\", \"-c\", \"tail -f /var/log/app.log\"]\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log\n\n  # Shared Storage allowing them to talk via disk\n  volumes:\n    - name: shared-logs\n      emptyDir: {}\n```\n\n## 7\\. Common Sidecar Types\n\n### A. The Ambassador (Proxy)\n\n  * **Role:** Handles network connectivity.\n  * **Example:** The app wants to call the \"Payment Service.\" It calls `localhost:9000`. The Sidecar listens on 9000, looks up the Payment Service in Service Discovery, encrypts the request with mTLS, and sends it over the network.\n  * **Benefit:** The developer doesn't need to know about Service Discovery or Certificates.\n\n### B. The Adapter\n\n  * **Role:** Standardizes output.\n  * **Example:** You have a Legacy App that outputs monitoring data in `XML`. Your modern system uses `Prometheus (JSON)`.\n  * **Action:** The Sidecar calls the Legacy App, reads the XML, converts it to JSON, and exposes a `/metrics` endpoint for Prometheus.\n\n### C. The Offloader\n\n  * **Role:** Handles minor tasks to free up the main app.\n  * **Example:** A \"Git Sync\" sidecar that periodically pulls the latest configuration files from a Git repository and saves them to a shared volume so the Main App always reads the latest config.\n\n## 8\\. Strategic Value\n\nThe Sidecar pattern is the enabler of the **\"Operational Plane\"** vs. the **\"Data Plane.\"**\n\n  * **Developers** own the Main Container (Code).\n  * **DevOps/Platform Engineers** own the Sidecar Container (Infrastructure).\n  * This organizational decoupling is often more valuable than the technical decoupling."
    },
    {
      "rel_path": "02-structural-and-decoupling/10-hexagonal-architecture.md",
      "ext": ".md",
      "size_bytes": 5763,
      "kind": "markdown",
      "content": "# 10\\. Hexagonal Architecture (Ports & Adapters)\n\n## 1\\. The Concept\n\nHexagonal Architecture (also known as Ports and Adapters) is a pattern used to create loosely coupled application components that can be easily connected to their software environment by means of ports and adapters. It aims to make your application core independent of frameworks, user interfaces, databases, and external systems.\n\n## 2\\. The Problem\n\n  * **Scenario:** You build a standard \"Layered Architecture\" (Controller -\\> Service -\\> Repository -\\> Database).\n  * **The Risk:**\n      * **Database Coupling:** Your Service layer (Business Logic) often imports SQL libraries or ORM objects (like `SQLAlchemy` or `Hibernate`). If you want to switch from SQL to MongoDB, you have to rewrite your Business Logic.\n      * **Testing Pain:** To test your logic, you have to spin up a real database or use complex mocking because the logic is inextricably linked to the data access code.\n      * **Framework Lock-in:** Your core logic becomes cluttered with annotations (`@Entity`, `@Controller`) that tie you to a specific web framework.\n\n## 3\\. The Solution\n\nWe treat the application as a **Hexagon** (the Core).\n\n1.  **The Core:** Contains the Business Logic and Domain Entities. It has **zero dependencies** on the outside world.\n2.  **Ports:** Interfaces defined by the Core. The Core says, \"I need a way to Save a User\" (Output Port) or \"I handle the command Create User\" (Input Port).\n3.  **Adapters:** The implementation of those interfaces.\n      * **Driving Adapters (Primary):** The things that start the action (REST API, CLI, Test Suite). They call the Input Ports.\n      * **Driven Adapters (Secondary):** The things the application needs to talk to (Postgres, SMTP, Redis). They implement the Output Ports.\n\n### Junior vs. Senior View\n\n| Perspective | Approach | Outcome |\n| :--- | :--- | :--- |\n| **Junior** | \"I'll put the SQL query inside the `UserService` class because that's where the data is needed.\" | **Tight Coupling.** The business rules are mixed with infrastructure concerns. You cannot test the logic without a running database. |\n| **Senior** | \"The `UserService` should define a `UserRepository` interface. The implementation (`SqlUserRepository`) lives outside the core. The service never imports SQL code.\" | **Testability & Flexibility.** We can swap SQL for a CSV file or a Mock for unit testing without touching a single line of business logic. |\n\n## 4\\. Visual Diagram\n\n## 5\\. When to Use It (and When NOT to)\n\n  * ‚úÖ **Use when:**\n      * **Complex Domain Logic:** The business rules are complicated and need to be tested in isolation.\n      * **Long-Term Maintenance:** You expect the app to live for years and might change technologies (e.g., swapping REST for gRPC, or Oracle for Mongo).\n      * **TDD (Test Driven Development):** You want to write tests for the core logic before the database schema even exists.\n  * ‚ùå **Avoid when:**\n      * **CRUD Apps:** If the app just reads rows from a DB and shows them as JSON, this architecture adds massive boilerplate (Interface + Impl + DTOs) for zero value. Use a simple MVC framework instead.\n\n## 6\\. Implementation Example (Pseudo-code)\n\n**Goal:** Create a user.\n\n### 1\\. The Core (Inner Hexagon)\n\n*Pure Python/Java. No frameworks. No SQL.*\n\n```python\n# --- The Domain Entity ---\nclass User:\n    def __init__(self, username, email):\n        if \"@\" not in email:\n            raise ValueError(\"Invalid email\")\n        self.username = username\n        self.email = email\n\n# --- The Output Port (Interface) ---\n# The Core asks: \"I need someone to save this.\"\nclass UserRepositoryPort:\n    def save(self, user: User):\n        raise NotImplementedError()\n\n# --- The Input Port (Service/UseCase) ---\nclass CreateUserUseCase:\n    def __init__(self, user_repo: UserRepositoryPort):\n        self.user_repo = user_repo\n\n    def execute(self, username, email):\n        # 1. Business Logic\n        user = User(username, email)\n        \n        # 2. Use the Port (we don't know HOW it saves, just THAT it saves)\n        self.user_repo.save(user)\n        return user\n```\n\n### 2\\. The Adapters (Outer Layer)\n\n*Frameworks, Database Drivers, HTTP.*\n\n```python\n# --- Driven Adapter (Infrastructure) ---\nimport sqlite3\n\nclass SqliteUserRepository(UserRepositoryPort):\n    def save(self, user: User):\n        # Specific SQL implementation details\n        conn = sqlite3.connect(\"db.sqlite\")\n        cursor = conn.cursor()\n        cursor.execute(\"INSERT INTO users VALUES (?, ?)\", (user.username, user.email))\n        conn.commit()\n\n# --- Driving Adapter (Web Controller) ---\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n# Wire it up (Dependency Injection)\nrepo = SqliteUserRepository()\nuse_case = CreateUserUseCase(repo) \n\n@app.route(\"/users\", methods=[\"POST\"])\ndef create_user():\n    data = request.json\n    use_case.execute(data['username'], data['email'])\n    return \"Created\", 201\n```\n\n### 3\\. The Test Adapter (Why this is powerful)\n\nWe can run the core logic tests in milliseconds because we don't need a real DB.\n\n```python\nclass MockRepo(UserRepositoryPort):\n    def save(self, user):\n        print(\"Pretend saved to DB\")\n\ndef test_create_user_logic():\n    repo = MockRepo()\n    use_case = CreateUserUseCase(repo)\n    \n    # This runs purely in memory\n    user = use_case.execute(\"john\", \"john@example.com\")\n    assert user.username == \"john\"\n```\n\n## 7\\. Key Takeaway\n\nHexagonal Architecture allows you to delay technical decisions. You can write the entire application core before you even decide which database to use. The database becomes a detail, not the foundation."
    },
    {
      "rel_path": "02-structural-and-decoupling/11-backend-for-frontend-bff.md",
      "ext": ".md",
      "size_bytes": 5246,
      "kind": "markdown",
      "content": "# 11\\. Backend for Frontend (BFF)\n\n## 1\\. The Concept\n\nThe Backend for Frontend (BFF) pattern creates separate backend services to be consumed by specific frontend applications. Instead of having one \"General Purpose API\" that tries to satisfy the Mobile App, the Web Dashboard, and the 3rd Party Integrations all at once, you build a dedicated API layer for each interface.\n\n## 2\\. The Problem\n\n  * **Scenario:** You have a single \"User Service\" API.\n      * The **Desktop Web App** needs rich data: User details, last 10 orders, invoices, and activity logs to fill a large screen.\n      * The **Mobile App** (running on 4G) needs minimal data: Just the User Name and Avatar to show in the header.\n  * **The Risk (The One-Size-Fits-None):**\n      * **Over-fetching (Mobile Pain):** If the Mobile App calls the generic API, it downloads a massive 50KB JSON object just to display a name. This wastes the user's data plan and drains the battery.\n      * **Under-fetching (Chatty Interfaces):** If the API is too granular, the Desktop App has to make 5 parallel network calls just to render one page.\n\n## 3\\. The Solution\n\nBuild a specific adapter layer for each frontend experience.\n\n  * **Mobile BFF:** Calls the downstream microservices, strips out heavy data, and returns a lean JSON response tailored exactly to the mobile screen size.\n  * **Web BFF:** Calls multiple microservices, aggregates the responses into a single rich object, and sends it to the browser.\n\nThe BFF is owned by the *Frontend Team*, not the Backend Team. It is part of the \"client experience,\" just running on the server.\n\n### Junior vs. Senior View\n\n| Perspective | Approach | Outcome |\n| :--- | :--- | :--- |\n| **Junior** | \"We have one REST API. If the mobile team needs less data, they can just ignore the fields they don't need.\" | **Performance Bloat.** Mobile users suffer from slow load times. The API becomes a mess of optional parameters like `?exclude_logs=true&include_orders=false`. |\n| **Senior** | \"The Mobile team builds a Node.js BFF. It formats the data exactly how their UI needs it. The Core API stays generic and clean.\" | **Optimized UX.** Mobile gets tiny payloads. Web gets rich payloads. The Core Services don't need to change every time the UI changes. |\n\n## 4\\. Visual Diagram\n\n## 5\\. When to Use It (and When NOT to)\n\n  * ‚úÖ **Use when:**\n      * **Distinct Interfaces:** The Mobile UI is significantly different from the Web UI (e.g., simplified flows, different data requirements).\n      * **Team Scaling:** You have separate teams for Mobile and Web. The Mobile team can update their BFF without waiting for the Backend team to deploy API changes.\n      * **Aggregating Microservices:** Your frontend needs to call 6 different services to build the home page. Do that aggregation in the BFF (server-side, low latency) rather than the browser.\n  * ‚ùå **Avoid when:**\n      * **Single Interface:** If you only have a Web App, a BFF is just useless extra code.\n      * **Similar Needs:** If the Mobile App and Web App look exactly the same and use the same data, just use a common API.\n\n## 6\\. Implementation Example (Pseudo-code)\n\n**Scenario:** We need to render the \"Order History\" page.\n\n### The Downstream Microservices (Generic)\n\n  * `OrderService`: Returns massive JSON with shipping details, tax codes, warehouse IDs.\n  * `ProductService`: Returns images, descriptions, specs.\n\n### 1\\. The Mobile BFF (Optimized for Bandwidth)\n\n*The Mobile screen only shows a list of Item Names and Prices.*\n\n```javascript\n// MobileBFF/controllers/orders.js\nasync function getMobileOrders(userId) {\n    // 1. Fetch raw data\n    const rawOrders = await OrderService.getAll(userId);\n    \n    // 2. Transform & Strip Data\n    const mobileData = rawOrders.map(order => ({\n        id: order.id,\n        date: order.created_at,\n        total: order.final_price_usd, // Formatted string\n        status: order.status\n        // REMOVED: tax_details, shipping_address, warehouse_logs, item_specs\n    }));\n\n    return mobileData; // Payload size: 2KB\n}\n```\n\n### 2\\. The Web BFF (Optimized for Richness)\n\n*The Web Dashboard shows everything, plus product images.*\n\n```javascript\n// WebBFF/controllers/orders.js\nasync function getWebOrders(userId) {\n    // 1. Fetch raw orders\n    const orders = await OrderService.getAll(userId);\n    \n    // 2. Fetch extra product details for every item (Aggregation)\n    // The browser doesn't have to make these calls!\n    for (let order of orders) {\n        order.product_images = await ProductService.getImages(order.product_ids);\n        order.invoices = await InvoiceService.getByOrder(order.id);\n    }\n\n    return orders; // Payload size: 50KB\n}\n```\n\n## 7\\. Operational Notes\n\n  * **Keep it Logic-Free:** The BFF should contain **Presentation Logic** (formatting, sorting, aggregating), not **Business Logic** (calculating tax, validating inventory). Business logic belongs in the Core Services.\n  * **GraphQL as a BFF:** Many teams use GraphQL as a \"Universal BFF.\" The frontend queries exactly what it needs (`{ user { name } }`), effectively solving the over-fetching problem without writing manual BFF controllers.\n"
    },
    {
      "rel_path": "02-structural-and-decoupling/README.md",
      "ext": ".md",
      "size_bytes": 3170,
      "kind": "markdown",
      "content": "# üß¨ Group 2: Structural & Decoupling\n\n## Overview\n\n**\"The only constant is change. Architecture is the art of making change easy.\"**\n\nIf Group 1 was about keeping the system *alive*, Group 2 is about keeping the system *maintainable*. As systems grow, they tend to become \"Big Balls of Mud\"‚Äîtangled webs of dependencies where changing one line of code breaks a feature three modules away.\n\nThese patterns provide the strategies to modularize systems, isolate dependencies, and modernize legacy codebases without the risky \"Big Bang Rewrite.\" They allow you to swap out databases, upgrade frameworks, or split monoliths with surgical precision.\n\n## üìú Pattern Index\n\n| Pattern | Goal | Senior \"Soundbite\" |\n| :--- | :--- | :--- |\n| **[07. Strangler Fig](https://www.google.com/search?q=./07-strangler-fig.md)** | **Legacy Migration** | \"Don't rewrite the monolith. Grow the new system around it until the old one dies.\" |\n| **[08. Anti-Corruption Layer](https://www.google.com/search?q=./08-anti-corruption-layer.md)** | **Boundary Protection** | \"Never let the legacy system's bad naming conventions leak into our clean domain.\" |\n| **[09. Sidecar Pattern](https://www.google.com/search?q=./09-sidecar-pattern.md)** | **Infra Offloading** | \"The application code shouldn't know how to encrypt SSL or ship logs.\" |\n| **[10. Hexagonal Architecture](https://www.google.com/search?q=./10-hexagonal-architecture.md)** | **Logic Isolation** | \"I should be able to test the core business logic without spinning up a database.\" |\n| **[11. Backend for Frontend](https://www.google.com/search?q=./11-backend-for-frontend-bff.md)** | **UI Optimization** | \"The mobile app has different data needs than the desktop app. Don't force them to share one generic API.\" |\n\n## üß† The Structural Checklist\n\nBefore approving a pull request or design document, a Senior Architect asks:\n\n1.  **The \"Database Swap\" Test:** If we decided to switch from MySQL to MongoDB next year, how much business logic would we have to rewrite? (Ideally: None, only the Adapters).\n2.  **The \"Vendor Lock-in\" Test:** If the 3rd-party Shipping Provider changes their API format, does it break our internal `Order` class? (It shouldn't, if an ACL is present).\n3.  **The \"Team Autonomy\" Test:** Can the Mobile Team release a new feature without begging the Backend Team to change the core database schema? (BFF helps here).\n4.  **The \"Zombie\" Test:** Do we have a plan to *finish* the migration, or will we be running the Strangler Fig pattern for 5 years?\n\n## ‚ö†Ô∏è Common Pitfalls in This Module\n\n  * **The Distributed Monolith:** You split your code into microservices, but they are so tightly coupled (sharing databases, synchronous calls) that you still have to deploy them all at once. This is worse than a regular monolith.\n  * **Abstraction Overdose:** Creating 15 layers of interfaces (Ports/Adapters) for a simple \"Hello World\" app. Structural patterns pay off *only* when complexity is high.\n  * **The \"Universal\" API:** Trying to build one single REST API that perfectly serves Mobile, Web, Watch, and IoT devices. It inevitably serves none of them well.\n\n"
    }
  ]
}